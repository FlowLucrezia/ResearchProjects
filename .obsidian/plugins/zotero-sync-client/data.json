{
  "api_key": "VbDn0A2Qg872VOHTQCYSymeA",
  "sync_on_startup": true,
  "sync_on_interval": false,
  "sync_interval": 0,
  "note_generator": "let n = '';\nif (data.creators) {\n\tdata.creators.forEach(author => {\n\t\tn += '[[People/' + author.firstName + ' ' + author.lastName + ']] '; \n\t});\n\tn += '\\n';\n}\nn += '# ' + data.title;\n\nif (data.date) {\n\tlet year;\n\t// Try parsing the date using Date object\n\tlet parsedDate = new Date(data.date);\n\tif (!isNaN(parsedDate)) {\n\t\tyear = parsedDate.getFullYear();\n\t} else {\n\t\t// Fallback: extract year using regex if date is inconsistent\n\t\tlet match = data.date.match(/(\\d{4})/);\n\t\tif (match) {\n\t\t\tyear = match[1];\n\t\t} else {\n\t\t\tyear = 'Unknown'; // Use 'Unknown' if no year can be found\n\t\t}\n\t}\n\tn += ' (' + year + ')';\n}\n\nn += '\\n\\n';\nif (data.children) {\n\tconst notes = data.children.filter(\n\t\tc => c.itemType.toLowerCase() == 'note'\n\t);\n\tnotes.forEach(c => {\n\t\tn += c.note_markdown + '\\n\\n';\n\t});\n}\nreturn n;\n",
  "filepath_generator": "let fp = '';\nif (data.creators && data.creators.length > 0) {\n\tfp += data.creators[0]?.lastName;\n\tif (data.creators.length == 2) {\n\t\tfp += '+';\n\t\tfp += data.creators[1]?.lastName;\n\t} else if (data.creators.length > 2) {\n\t\tfp += '+';\n\t}\n\tif (data.date) {\n\t\tlet year;\n\t\t// Try parsing the date using Date object\n\t\tlet parsedDate = new Date(data.date);\n\t\tif (!isNaN(parsedDate)) {\n\t\t\tyear = parsedDate.getFullYear();\n\t\t} else {\n\t\t\t// Fallback: extract year using regex if date is inconsistent\n\t\t\tlet match = data.date.match(/(\\d{4})/);\n\t\t\tif (match) {\n\t\t\t\tyear = match[1];\n\t\t\t} else {\n\t\t\t\tyear = 'Unknown'; // Use 'Unknown' if no valid year can be found\n\t\t\t}\n\t\t}\n\t\tfp += year.toString();\n\t}\n\treturn 'References/' + fp;\n}\n"
}